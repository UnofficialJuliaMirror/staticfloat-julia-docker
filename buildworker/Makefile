include ../common.mk

buildall:

# Build mapping from buildbot name to worker base image
IMAGE-linux-x86_64-nanosoldier2_1=centos6_9-x64
IMAGE-linux-x86_64-nanosoldier2_2=centos6_9-x64
IMAGE-linux-i686-nanosoldier2_1=debian8_9-x86
IMAGE-linux-i686-nanosoldier2_2=debian8_9-x86
IMAGE-linux-ppc64le-osu=centos7_3-ppc64le
IMAGE-linux-aarch64-scaleway_1=centos7_3-aarch64
IMAGE-linux-aarch64-scaleway_2=centos7_3-aarch64
IMAGE-linux-armv7l-firefly=debian7_11-armv7l

BOTNAMES=
# Add x86_64 botnames
BOTNAMES += linux-x86_64-nanosoldier2_1
BOTNAMES += linux-x86_64-nanosoldier2_2
# Add i686 botnames
BOTNAMES += linux-i686-nanosoldier2_1
BOTNAMES += linux-i686-nanosoldier2_2
# Add ppc64le botnames
BOTNAMES += linux-ppc64le-osu
# Add aarch64 botnames
BOTNAMES += linux-aarch64-scaleway_1
BOTNAMES += linux-aarch64-scaleway_2
# Add armv7l botnames
BOTNAMES += linux-armv7l-firefly

# Extract the arch from a botname
define bot_arch
$(patsubst -%,,$(patsubst linux-%,%,$(1)))
endef

# Build mapping function from botname to worker base image
define bot_image
$(filter $(call bot_arch,$(1)),$(HFS))
endef

# Build "buildall" target that builds the docker-compose directories for each bot
$(foreach b,$(BOTNAMES),$(eval $(call add_dep,buildall,build-$(b))))

# Build "deployall" target that brings up all images that are compatible with our arch
BUILD_BOTNAMES=$(call BUILD_FILT,$(BOTNAMES))
$(foreach b,$(BUILD_BOTNAMES),$(eval $(call add_dep,deployall,deploy-$(b))))

# Build "downall" target that takes down all workers that are compatible with our arch
$(foreach b,$(BUILD_BOTNAMES),$(eval $(call add_dep,downall,down-$(b))))

# Here's where we take our templates and build docker-compose files out of them
define build_dockercompose
build-$(1): build/$(1)/docker-compose.yml build/$(1)/worker/Dockerfile build/$(1)/tabularasa/Dockerfile

build/$(1)/tabularasa/Dockerfile: Dockerfile.template start_worker.sh $(shell ../dockerdeps ../workerbase/$(call bot_image,$(1)).Dockerfile)
	@echo $(1)/tabularasa
	@# Build tabularasa directory
	@mkdir -p "build/$(1)/tabularasa"
	@echo "## This file was autogenerated" > "build/$(1)/tabularasa/Dockerfile"
	@echo "# Do not edit directly; edit the template files" >> "build/$(1)/tabularasa/Dockerfile"
	@echo "FROM $(call tabularasa_tag_name,$(1))" >> "build/$(1)/tabularasa/Dockerfile"
	@cat Dockerfile.template >> "build/$(1)/tabularasa/Dockerfile"
	@cp ./start_worker.sh "build/$(1)/tabularasa/start_worker.sh"

build/$(1)/worker/Dockerfile: Dockerfile.template start_worker.sh $(shell ../dockerdeps ../workerbase/$(call bot_image,$(1)).Dockerfile)
	@echo $(1)/worker
	@# Build worker directory
	@mkdir -p "build/$(1)/worker"
	@echo "## This file was autogenerated" > "build/$(1)/worker/Dockerfile"
	@echo "# Do not edit directly; edit the template files" >> "build/$(1)/worker/Dockerfile"
	@echo "FROM $(call worker_tag_name,$(1))" >> "build/$(1)/worker/Dockerfile"
	@cat Dockerfile.template >> "build/$(1)/worker/Dockerfile"
	@cp ./start_worker.sh "build/$(1)/worker/start_worker.sh"

build/$(1)/docker-compose.yml: docker-compose.template.yml override.env secret.env $(shell ../dockerdeps ../workerbase/$(call bot_image,$(1)).Dockerfile)
	@echo $(1)
	@mkdir -p "build/$(1)"
	@echo "## Autogenerated from secret.env and override.env" > "build/$(1)/.env"
	@cat secret.env >> "build/$(1)/.env"
	@[ ! -f override.env ] || cat override.env >> "build/$(1)/.env"
	@sed -e "s/{service_name}/$(1)/g" docker-compose.template.yml > "build/$(1)/docker-compose.yml"
	@sed -i.bak -e "s&{home}&$(HOME)&g" "build/$(1)/docker-compose.yml"
	@case $(call worker_tag_name,$(1)) in \
		*x86) sed -i.bak -e "s/{linux32}/linux32/g" "build/$(1)/docker-compose.yml";; \
		*)    sed -i.bak -e "s/{linux32}/       /g" "build/$(1)/docker-compose.yml";; \
	esac
	@rm -f build/$(1)/*.bak


pull-$(1):
	docker pull $(call worker_tag_name,$(1))

deploy-$(1): build-$(1) ipv6_internal
	@# chmod /var/run/docker.sock so that our docker guests can create images too
	@sudo chmod o+rw /var/run/docker.sock
	@# Build our new worker, take down the old one and bring the new one up
	@cd build/$(1); \
	docker-compose build --pull; \
	COMPOSE_HTTP_TIMEOUT=300 docker-compose up -d

down-$(1):
	@if [ -d build/$(1) ]; then \
		cd build/$(1); \
		docker-compose down --remove-orphans; \
	fi
endef

# Makefile target to make our internal ipv6 network
ipv6_internal:
	@if [ -z "$(shell docker network ls | grep ipv6_internal)" ]; then \
		docker network create --internal --ipv6 --subnet "fdeb:feed:face::/48" ipv6_internal; \
	fi

# Call build_dockercompose on each and every bot
$(foreach b,$(BOTNAMES),$(eval $(call build_dockercompose,$(b))))


clean:
	rm -rf build
